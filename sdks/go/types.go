// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	big "math/big"
	internal "sdk/internal"
	time "time"
)

var (
	plantCreatedPayloadFieldEvent     = big.NewInt(1 << 0)
	plantCreatedPayloadFieldTimestamp = big.NewInt(1 << 1)
	plantCreatedPayloadFieldData      = big.NewInt(1 << 2)
)

type PlantCreatedPayload struct {
	Event     *PlantCreatedPayloadEvent `json:"event,omitempty" url:"event,omitempty"`
	Timestamp *time.Time                `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	Data      *PlantResponse            `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PlantCreatedPayload) GetEvent() *PlantCreatedPayloadEvent {
	if p == nil {
		return nil
	}
	return p.Event
}

func (p *PlantCreatedPayload) GetTimestamp() *time.Time {
	if p == nil {
		return nil
	}
	return p.Timestamp
}

func (p *PlantCreatedPayload) GetData() *PlantResponse {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PlantCreatedPayload) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PlantCreatedPayload) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetEvent sets the Event field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PlantCreatedPayload) SetEvent(event *PlantCreatedPayloadEvent) {
	p.Event = event
	p.require(plantCreatedPayloadFieldEvent)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PlantCreatedPayload) SetTimestamp(timestamp *time.Time) {
	p.Timestamp = timestamp
	p.require(plantCreatedPayloadFieldTimestamp)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PlantCreatedPayload) SetData(data *PlantResponse) {
	p.Data = data
	p.require(plantCreatedPayloadFieldData)
}

func (p *PlantCreatedPayload) UnmarshalJSON(data []byte) error {
	type embed PlantCreatedPayload
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PlantCreatedPayload(unmarshaler.embed)
	p.Timestamp = unmarshaler.Timestamp.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PlantCreatedPayload) MarshalJSON() ([]byte, error) {
	type embed PlantCreatedPayload
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed:     embed(*p),
		Timestamp: internal.NewOptionalDateTime(p.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PlantCreatedPayload) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PlantCreatedPayloadEvent string

const (
	PlantCreatedPayloadEventPlantCreated PlantCreatedPayloadEvent = "plant.created"
)

func NewPlantCreatedPayloadEventFromString(s string) (PlantCreatedPayloadEvent, error) {
	switch s {
	case "plant.created":
		return PlantCreatedPayloadEventPlantCreated, nil
	}
	var t PlantCreatedPayloadEvent
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PlantCreatedPayloadEvent) Ptr() *PlantCreatedPayloadEvent {
	return &p
}

var (
	postPlantUpdatedPayloadFieldEvent     = big.NewInt(1 << 0)
	postPlantUpdatedPayloadFieldTimestamp = big.NewInt(1 << 1)
	postPlantUpdatedPayloadFieldData      = big.NewInt(1 << 2)
)

type PostPlantUpdatedPayload struct {
	Event     *PostPlantUpdatedPayloadEvent `json:"event,omitempty" url:"event,omitempty"`
	Timestamp *time.Time                    `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	Data      *PlantResponse                `json:"data,omitempty" url:"data,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PostPlantUpdatedPayload) GetEvent() *PostPlantUpdatedPayloadEvent {
	if p == nil {
		return nil
	}
	return p.Event
}

func (p *PostPlantUpdatedPayload) GetTimestamp() *time.Time {
	if p == nil {
		return nil
	}
	return p.Timestamp
}

func (p *PostPlantUpdatedPayload) GetData() *PlantResponse {
	if p == nil {
		return nil
	}
	return p.Data
}

func (p *PostPlantUpdatedPayload) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PostPlantUpdatedPayload) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetEvent sets the Event field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PostPlantUpdatedPayload) SetEvent(event *PostPlantUpdatedPayloadEvent) {
	p.Event = event
	p.require(postPlantUpdatedPayloadFieldEvent)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PostPlantUpdatedPayload) SetTimestamp(timestamp *time.Time) {
	p.Timestamp = timestamp
	p.require(postPlantUpdatedPayloadFieldTimestamp)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PostPlantUpdatedPayload) SetData(data *PlantResponse) {
	p.Data = data
	p.require(postPlantUpdatedPayloadFieldData)
}

func (p *PostPlantUpdatedPayload) UnmarshalJSON(data []byte) error {
	type embed PostPlantUpdatedPayload
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = PostPlantUpdatedPayload(unmarshaler.embed)
	p.Timestamp = unmarshaler.Timestamp.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PostPlantUpdatedPayload) MarshalJSON() ([]byte, error) {
	type embed PostPlantUpdatedPayload
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed:     embed(*p),
		Timestamp: internal.NewOptionalDateTime(p.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PostPlantUpdatedPayload) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PostPlantUpdatedPayloadEvent string

const (
	PostPlantUpdatedPayloadEventPlantUpdated PostPlantUpdatedPayloadEvent = "plant.updated"
)

func NewPostPlantUpdatedPayloadEventFromString(s string) (PostPlantUpdatedPayloadEvent, error) {
	switch s {
	case "plant.updated":
		return PostPlantUpdatedPayloadEventPlantUpdated, nil
	}
	var t PostPlantUpdatedPayloadEvent
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PostPlantUpdatedPayloadEvent) Ptr() *PostPlantUpdatedPayloadEvent {
	return &p
}

var (
	webhookRegistrationFieldUrl    = big.NewInt(1 << 0)
	webhookRegistrationFieldEvents = big.NewInt(1 << 1)
	webhookRegistrationFieldSecret = big.NewInt(1 << 2)
)

type WebhookRegistration struct {
	// The URL where webhook events will be sent
	Url string `json:"url" url:"url"`
	// List of events to subscribe to
	Events []WebhookRegistrationEventsItem `json:"events" url:"events"`
	// Secret used to sign webhook payloads
	Secret *string `json:"secret,omitempty" url:"secret,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *WebhookRegistration) GetUrl() string {
	if w == nil {
		return ""
	}
	return w.Url
}

func (w *WebhookRegistration) GetEvents() []WebhookRegistrationEventsItem {
	if w == nil {
		return nil
	}
	return w.Events
}

func (w *WebhookRegistration) GetSecret() *string {
	if w == nil {
		return nil
	}
	return w.Secret
}

func (w *WebhookRegistration) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WebhookRegistration) require(field *big.Int) {
	if w.explicitFields == nil {
		w.explicitFields = big.NewInt(0)
	}
	w.explicitFields.Or(w.explicitFields, field)
}

// SetUrl sets the Url field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WebhookRegistration) SetUrl(url string) {
	w.Url = url
	w.require(webhookRegistrationFieldUrl)
}

// SetEvents sets the Events field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WebhookRegistration) SetEvents(events []WebhookRegistrationEventsItem) {
	w.Events = events
	w.require(webhookRegistrationFieldEvents)
}

// SetSecret sets the Secret field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WebhookRegistration) SetSecret(secret *string) {
	w.Secret = secret
	w.require(webhookRegistrationFieldSecret)
}

func (w *WebhookRegistration) UnmarshalJSON(data []byte) error {
	type unmarshaler WebhookRegistration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebhookRegistration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *WebhookRegistration) MarshalJSON() ([]byte, error) {
	type embed WebhookRegistration
	var marshaler = struct {
		embed
	}{
		embed: embed(*w),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, w.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (w *WebhookRegistration) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

type WebhookRegistrationEventsItem string

const (
	WebhookRegistrationEventsItemPlantCreated       WebhookRegistrationEventsItem = "plant.created"
	WebhookRegistrationEventsItemPlantUpdated       WebhookRegistrationEventsItem = "plant.updated"
	WebhookRegistrationEventsItemPlantStatusChanged WebhookRegistrationEventsItem = "plant.status_changed"
	WebhookRegistrationEventsItemPlantDeleted       WebhookRegistrationEventsItem = "plant.deleted"
)

func NewWebhookRegistrationEventsItemFromString(s string) (WebhookRegistrationEventsItem, error) {
	switch s {
	case "plant.created":
		return WebhookRegistrationEventsItemPlantCreated, nil
	case "plant.updated":
		return WebhookRegistrationEventsItemPlantUpdated, nil
	case "plant.status_changed":
		return WebhookRegistrationEventsItemPlantStatusChanged, nil
	case "plant.deleted":
		return WebhookRegistrationEventsItemPlantDeleted, nil
	}
	var t WebhookRegistrationEventsItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WebhookRegistrationEventsItem) Ptr() *WebhookRegistrationEventsItem {
	return &w
}

var (
	webhookResponseFieldId     = big.NewInt(1 << 0)
	webhookResponseFieldUrl    = big.NewInt(1 << 1)
	webhookResponseFieldEvents = big.NewInt(1 << 2)
	webhookResponseFieldStatus = big.NewInt(1 << 3)
)

type WebhookResponse struct {
	// Unique identifier for the webhook
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// The URL where webhook events are sent
	Url *string `json:"url,omitempty" url:"url,omitempty"`
	// List of subscribed events
	Events []string `json:"events,omitempty" url:"events,omitempty"`
	// Current status of the webhook
	Status *WebhookResponseStatus `json:"status,omitempty" url:"status,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (w *WebhookResponse) GetId() *string {
	if w == nil {
		return nil
	}
	return w.Id
}

func (w *WebhookResponse) GetUrl() *string {
	if w == nil {
		return nil
	}
	return w.Url
}

func (w *WebhookResponse) GetEvents() []string {
	if w == nil {
		return nil
	}
	return w.Events
}

func (w *WebhookResponse) GetStatus() *WebhookResponseStatus {
	if w == nil {
		return nil
	}
	return w.Status
}

func (w *WebhookResponse) GetExtraProperties() map[string]interface{} {
	return w.extraProperties
}

func (w *WebhookResponse) require(field *big.Int) {
	if w.explicitFields == nil {
		w.explicitFields = big.NewInt(0)
	}
	w.explicitFields.Or(w.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WebhookResponse) SetId(id *string) {
	w.Id = id
	w.require(webhookResponseFieldId)
}

// SetUrl sets the Url field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WebhookResponse) SetUrl(url *string) {
	w.Url = url
	w.require(webhookResponseFieldUrl)
}

// SetEvents sets the Events field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WebhookResponse) SetEvents(events []string) {
	w.Events = events
	w.require(webhookResponseFieldEvents)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (w *WebhookResponse) SetStatus(status *WebhookResponseStatus) {
	w.Status = status
	w.require(webhookResponseFieldStatus)
}

func (w *WebhookResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler WebhookResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*w = WebhookResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *w)
	if err != nil {
		return err
	}
	w.extraProperties = extraProperties
	w.rawJSON = json.RawMessage(data)
	return nil
}

func (w *WebhookResponse) MarshalJSON() ([]byte, error) {
	type embed WebhookResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*w),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, w.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (w *WebhookResponse) String() string {
	if len(w.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(w.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(w); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", w)
}

// Current status of the webhook
type WebhookResponseStatus string

const (
	WebhookResponseStatusActive   WebhookResponseStatus = "active"
	WebhookResponseStatusInactive WebhookResponseStatus = "inactive"
)

func NewWebhookResponseStatusFromString(s string) (WebhookResponseStatus, error) {
	switch s {
	case "active":
		return WebhookResponseStatusActive, nil
	case "inactive":
		return WebhookResponseStatusInactive, nil
	}
	var t WebhookResponseStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (w WebhookResponseStatus) Ptr() *WebhookResponseStatus {
	return &w
}
